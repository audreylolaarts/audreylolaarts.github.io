<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300..700&display=swap" rel="stylesheet">
<style>

    
html, body {
  height: 100%;
  margin: 0;
  font-family: 'Cormorant Garamond', serif;
  scroll-behavior: smooth;
  background: white;
  overflow: hidden;
}
.scroll-container {
  height: 100%;
  overflow-y: scroll;
  scroll-snap-type: y mandatory;
}
.section {
  height: 100vh;
  scroll-snap-align: start;
  position: relative;
}
.grid1, .grid2 {
  position: absolute;
  top: 10vh;
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 10px;
  width: 20vw;
  z-index: 5;
}
.grid1 { left: 2vw; }
.grid2 { right: 2vw; filter: invert(100%); }
.grid1 img, .grid2 img {
  width: 100%;
  height: auto;
  object-fit: cover;
  background: black;
  opacity: 0;
}
.play .grid1 img,
.play .grid2 img { animation: fadeInOut 15s infinite; }
@keyframes fadeInOut {
  0%,100% { opacity: 0; }
  50% { opacity: 0.5; }
}
.grid1 img:nth-child(1) { animation-delay: 0s; }
.grid1 img:nth-child(2) { animation-delay: 0.25s; }
.grid1 img:nth-child(3) { animation-delay: 0.5s; }
.grid1 img:nth-child(4) { animation-delay: 0.75s; }
.grid1 img:nth-child(5) { animation-delay: 1s; }
.grid1 img:nth-child(6) { animation-delay: 1.25s; }
.grid2 img:nth-child(1) { animation-delay: 1.5s; }
.grid2 img:nth-child(2) { animation-delay: 1.75s; }
.grid2 img:nth-child(3) { animation-delay: 2s; }
.grid2 img:nth-child(4) { animation-delay: 2.25s; }
.grid2 img:nth-child(5) { animation-delay: 2.5s; }
.grid2 img:nth-child(6) { animation-delay: 2.75s; }
.text-block-1 {
  position:absolute;
  left:30vw; top:10vh; width:40vw; font-size:28px;
  z-index: 10;
}
.arrow {
  position: absolute;
  left: 50%; bottom: 5vh;
  transform: translateX(-50%);
  font-size: 90px;
  opacity: 0;
  animation: bounceArrow 2s infinite;
  animation-delay: 6s;
  animation-fill-mode: forwards;
  z-index: 10;
}
@keyframes bounceArrow {
  0%   { opacity: 0; transform: translate(-50%,0); }
  1%   { opacity: 1; transform: translate(-50%,0); }
  50%  { transform: translate(-50%,15px); }
  100% { transform: translate(-50%,0); }
}
canvas {
  position: absolute;
  top:0; left:0;
  width: 100%;
  height: 100%;
  display: block;
  background-color: white;
  z-index: 1;
}
.section:nth-child(2) { background: #f5f5f5; }
.intro-text {
  position: absolute;
  top: 40%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 28px;
  text-align: center;
  color: black;
  opacity: 1;
  transition: opacity 2s ease;
  pointer-events: none;
  z-index: 10;
}
.scroll-arrow-next {
  position: absolute;
  left: 50%;
  bottom: 5vh;
  transform: translateX(-50%);
  font-size: 90px;
  opacity: 0;
  transition: opacity 1s ease;
  cursor: pointer;
  z-index: 20;
}
.scroll-arrow-next.show {
  opacity: 1;
  animation: bounceArrow 2s infinite;
}
#paper-container {
  max-width: 70%;
  margin: 10vh auto;
  font-size: 20px;
  line-height: 1.6;
  top:10vh;
}
#paper-title { font-size: 28px; font-weight: bold; margin-bottom: 1rem; }
#paper-abstract { margin-bottom: 1rem; }
#paper-authors { font-size: 18px; color: #555; margin-bottom: 2rem; }
#load-paper {
  display: block;
  margin: 2rem auto;
  font-size: 20px;
  padding: 10px 20px;
  border: 1px solid black;
  background: white;
  cursor: pointer;
}
.page4-anim {
  opacity: 0;              /* hidden by default to avoid flash */
  will-change: opacity;    /* hint for smoother animation */
}
.fade-in { opacity: 0; animation: fadeIn 2s forwards; }
.fade-in.delay-1 { animation-delay: 0.5s; }
.fade-in.delay-2 { animation-delay: 2s; }
.fade-in.delay-3 { animation-delay: 4s; }
@keyframes fadeIn { to { opacity: 1; } }
.arrow-right {
  display: inline-block;
  margin-left: 10px;
  font-size: 28px;
  transform: translateX(0);
  animation: bounceRight 1.5s infinite;
}

@keyframes bounceRight {
  0%, 100% { transform: translateX(0); }
  50% { transform: translateX(15px); }
}
</style>
</head>
<body>
<div class="scroll-container" id="scroll-container">

  <div class="section">
    <div class="grid1">
      <img src="assets/img1.png" alt="">
      <img src="assets/img2.png" alt="">
      <img src="assets/img3.png" alt="">
      <img src="assets/img4.png" alt="">
      <img src="assets/img5.png" alt="">
      <img src="assets/img6.png" alt="">
    </div>
    <div class="grid2">
      <img src="assets/img7.png" alt="">
      <img src="assets/img8.png" alt="">
      <img src="assets/img9.png" alt="">
      <img src="assets/img10.png" alt="">
      <img src="assets/img11.png" alt="">
      <img src="assets/img12.png" alt="">
    </div>
    <div class="text-block-1">
      Whether or not something is "natural" is a conceptual line that humans draw, <br>
      or maybe feel.<br><br>
      Sometimes that distinction, natural vs unnatural, feels very alienating. Other times, it melts away. </span><br><br>
      I find comfort in the idea that mathematics is indifferent;
it reveals continuity across both sides of the line.<br>
<span style="opacity:0.3">The cold comfort of a faraway star though... certainly not a warm touch.</span><br>
      <br>
      The Voronoi tessellation is a fun illustration of this idea.
    </div>
    <div class="arrow">&#8595;</div>
  </div>

  <div class="section" id="falling-words-section">
    <canvas id="words-canvas"></canvas>
    <div class="intro-text" id="intro-text">
      There are so many applications of Voronoi patternsâ€” it's dizzying.
    </div>
    <div class="scroll-arrow-next" id="next-arrow">&#8595;</div>
  </div>

</div>

<script>
window.addEventListener('load', () => { document.body.classList.add('play'); });

const wordsList = [
  "Modeling cell tissue structures in biology",
  "Simulating foam bubbles in materials science",
  "Distribution of sensors in environmental monitoring",
  "Modeling territorial behavior in animal populations",
  "Designing porous scaffolds for tissue engineering",
  "Allocating fire stations efficiently in a city",
  "Analyzing rainfall patterns in hydrology",
  "Generating natural-looking textures in computer graphics",
  "Simulating oil droplet distribution in emulsions",
  "Modeling bee hive hexagonal cell structures",
  "Representing network coverage areas in telecom",
  "Modeling cellular automata spatial relationships",
  "Predicting fracture patterns in concrete",
  "Studying galaxy clustering in cosmology",
  "Planning evacuation zones in disaster management",
  "Modeling foam drainage in chemical engineering",
  "Analyzing soap bubble dynamics",
  "Optimizing warehouse robot movement",
  "Designing efficient irrigation layouts",
  "Modeling gas bubble distributions in molten metals",
  "Predicting pollen dispersal in plants",
  "Studying fish schooling territories",
  "Representing spatial domains in epidemiology",
  "Simulating crowd dynamics in urban environments",
  "Modeling leaf vein patterns in botany",
  "Optimizing wind farm turbine layouts",
  "Studying granular material packing",
  "Modeling firefly light territory patterns",
  "Predicting animal feeding zones",
  "Designing optimized wireless mesh networks",
  "Modeling asteroid distributions in solar systems",
  "Simulating microfluidic channels",
  "Designing bone scaffold structures",
  "Modeling ant colony foraging regions",
  "Studying fungal hyphal networks",
  "Representing stress fields in materials",
  "Optimizing solar panel layouts",
  "Modeling blood vessel networks",
  "Simulating oil spill spread patterns",
  "Designing acoustic speaker arrays",
  "Modeling grain boundary networks in ceramics",
  "Studying coral reef spatial distributions",
  "Simulating predator-prey territories",
  "Modeling alveoli in lungs",
  "Studying urban green space distribution",
  "Optimizing sensor placement in robotics",
  "Representing molecular packing in chemistry",
  "Generating realistic cave networks",
  "Designing radar sensor networks",
  "Modeling leaf stomata distributions",
  "Optimizing hospital location coverage",
  "Designing microchip component layouts",
  "Modeling fracture propagation in geology",
  "Studying forest patch distribution",
  "Predicting bacterial colony growth",
  "Optimizing drone flight paths",
  "Modeling crystal nucleation points",
  "Simulating water droplet impact patterns",
  "Generating procedural coral reef layouts",
  "Studying habitat fragmentation effects",
  "Modeling protein folding spaces",
  "Designing efficient irrigation systems",
  "Predicting mineral deposit distributions",
  "Modeling territorial patterns in primates",
  "Generating 3D foam structures for visualization",
  "Studying urban traffic congestion zones",
  "Representing population density maps",
  "Modeling lava flow channels",
  "Optimizing distribution of vending machines",
  "Designing structural lattice in aerospace",
  "Studying swarming behavior in drones",
  "Modeling retinal cell distributions",
  "Simulating territorial dynamics in fish",
  "Designing antenna arrays",
  "Modeling honey bee comb patterns",
  "Studying coral polyp spacing",
  "Optimizing light sensor placement",
  "Modeling water droplet distribution on leaves",
  "Simulating territory in wolf packs",
  "Modeling packing of spheres in 3D space",
  "Predicting cellular automata evolution",
  "Representing ice crystal growth",
  "Studying seed dispersal patterns",
  "Designing mesh networks",
  "Simulating polymer foam structures",
  "Modeling galaxy formation patterns",
  "Optimizing UAV flight paths",
  "Representing plant root networks",
  "Studying hive temperature regulation",
  "Modeling bubble clusters in liquids",
  "Simulating crowd evacuation patterns",
  "Modeling heat diffusion zones",
  "Studying tree canopy coverage",
  "Representing gemstone crystal cuts",
  "Optimizing park layout distribution",
  "Modeling airflow over complex terrain",
  "Generating procedural maze layouts"
];

let animationStarted = false;
let page3Enabled = false;
let startIndex = 0;
let paperPool = [];
const section2 = document.getElementById('falling-words-section');
const introText = document.getElementById('intro-text');
const scrollContainer = document.getElementById('scroll-container');
const nextArrow = document.getElementById('next-arrow');

const observer = new IntersectionObserver(entries => {
  entries.forEach(entry => {
    if (entry.isIntersecting && !animationStarted) {
      animationStarted = true;
      setTimeout(() => { introText.style.opacity = 0; }, 2000);
      setTimeout(() => { startFallingWords(); }, 1600);
    }
  });
}, { threshold: 0.5 });

observer.observe(section2);

function startFallingWords() {
  const canvas = document.getElementById('words-canvas');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  function resizeCanvas() {
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);
  }
  resizeCanvas();

  class Word {
    constructor(text) {
      this.text = text;
      this.fontSize = 16 + Math.random()*8;
      this.angle = (Math.random()*40-20)*Math.PI/180;
      ctx.font = `${this.fontSize}px 'Cormorant Garamond'`;
      this.width = ctx.measureText(this.text).width;
      this.height = this.fontSize;
      this.x = Math.random() * (window.innerWidth - this.width);
      this.y = -this.height;
      this.vy = 2 + Math.random()*3;
      this.settled = false;
    }
    update(stack) {
      if (this.settled) return;
      this.y += this.vy;
      if (this.y + this.height >= window.innerHeight) {
        this.y = window.innerHeight - this.height;
        this.settled = true;
        stack.push(this);
        return;
      }
      for (let w of stack) {
        if (this.x < w.x + w.width &&
            this.x + this.width > w.x &&
            this.y + this.height > w.y &&
            this.y < w.y + w.height) {
          this.y = w.y - this.height + 4;
          this.settled = true;
          stack.push(this);
          return;
        }
      }
    }
    draw() {
      ctx.save();
      ctx.translate(this.x + this.width/2, this.y + this.height/2);
      ctx.rotate(this.settled ? 0 : this.angle);
      ctx.fillStyle = 'black';
      ctx.font = `${this.fontSize}px 'Cormorant Garamond'`;
      ctx.fillText(this.text, -this.width/2, this.height/2);
      ctx.restore();
    }
  }

  const fallingWords = [];
  const stack = [];
  const usedWords = new Set();
  const interval = setInterval(() => {
    if (usedWords.size >= wordsList.length) { clearInterval(interval); return; }
    let word;
    do { word = wordsList[Math.floor(Math.random() * wordsList.length)]; }
    while (usedWords.has(word));
    usedWords.add(word);
    fallingWords.push(new Word(word));
  }, 150);

  function animate() {
    ctx.clearRect(0,0,window.innerWidth,window.innerHeight);
    fallingWords.forEach(w => { w.update(stack); w.draw(); });
    if (stack.length < wordsList.length) {
      requestAnimationFrame(animate);
    } else if (!page3Enabled) {
      page3Enabled = true;

      // Show Page 2 arrow after all words settled
      nextArrow.classList.add('show');

      // Create Page 3 dynamically
      const page3 = document.createElement('div');
      page3.className = 'section';
      page3.innerHTML = `
        <div style="position:relative; top:10vh" id="paper-container">
          <button style="font-family: Cormorant Garamond, serif" id="load-paper">Keep clicking me for random papers on Voronoi Patterns</button>
          <div id="paper-title"></div>
          <div id="paper-abstract"></div>
          <div id="paper-authors"></div>
        </div>
        <div class="scroll-arrow-next" id="page3-arrow">&#8595;</div>
      `;
      scrollContainer.appendChild(page3);
      setupPaperFetcher();

      const arrow3 = page3.querySelector('#page3-arrow');
      arrow3.addEventListener('click', () => {
        const page4 = scrollContainer.querySelector('.section:nth-child(4)');
        if (page4) page4.scrollIntoView({behavior:'smooth'});
      });

      setTimeout(() => { addPage4(arrow3); }, 15000);
    }
  }

  animate();
  window.addEventListener('resize', resizeCanvas);

  nextArrow.addEventListener('click', () => {
    if (page3Enabled) document.querySelector('.section:nth-child(3)').scrollIntoView({behavior: 'smooth'});
  });
}

async function fetchPapers() {
  const url = `https://export.arxiv.org/api/query?search_query=ti:Voronoi&start=${startIndex}&max_results=50`;
  startIndex += 50;
  const response = await fetch(url);
  const text = await response.text();
  const parser = new DOMParser();
  const xml = parser.parseFromString(text, "application/xml");
  const entries = [...xml.getElementsByTagName("entry")];
  const papers = entries.map(e => ({
    title: e.getElementsByTagName("title")[0].textContent.trim(),
    summary: e.getElementsByTagName("summary")[0].textContent.trim(),
    authors: [...e.getElementsByTagName("author")].map(a => a.getElementsByTagName("name")[0].textContent)
  }));
  paperPool.push(...papers);
}

function setupPaperFetcher() {
  const btn = document.getElementById('load-paper');
  const titleEl = document.getElementById('paper-title');
  const abstractEl = document.getElementById('paper-abstract');
  const authorsEl = document.getElementById('paper-authors');

  btn.addEventListener('click', async () => {
    if (paperPool.length === 0) await fetchPapers();
    if (paperPool.length === 0) {
      titleEl.textContent = "No more papers available.";
      abstractEl.textContent = "";
      authorsEl.textContent = "";
      return;
    }
    const idx = Math.floor(Math.random() * paperPool.length);
    const paper = paperPool.splice(idx, 1)[0];
    titleEl.textContent = paper.title;
    abstractEl.textContent = "Abstract: " + paper.summary;
    authorsEl.textContent = "Authors: " + paper.authors.join(", ");
  });
}function addPage4(page3Arrow) {
  const page4 = document.createElement('div');
  page4.className = 'section';
  page4.innerHTML = `
    <div id="paper-container">
      <div style="top:50px; justify-content: center; font-size: 28px; font-weight: bold; margin-bottom: 1rem"
           class="page4-anim" data-delay="delay-1">
        this one's my fav I came across &lt;3
      </div>
      <div style="font-size: 28px; font-weight: bold; margin-bottom: 1rem"
           class="page4-anim" data-delay="delay-2" id="page4-title">
        The cosmic spiderweb: equivalence of cosmic, architectural and origami tessellations
      </div>
      <div style="margin-bottom: 2rem" class="page4-anim" data-delay="delay-3" id="page4-abstract"> "For over 20 years, the term <b>â€˜cosmic webâ€™</b> has guided our understanding of the large-scale arrangement of matter in the cosmos, accurately evoking the concept of a network of galaxies linked by filaments. But the physical correspondence between the cosmic web and structural engineering or textile <b>â€˜spiderwebsâ€™</b> is even deeper than previously known, and also extends to origami tessellations. Here, we explain that in a good structure-formation approximation known as the adhesion model, <b>threads of the cosmic web form a spiderweb</b>, i.e. can be strung up to be entirely in tension. <br> The <b>Voronoi foam</b> concept has also been instrumental in shaping our understanding of the large-scale arrangement of matter and galaxies in the universe. Indeed, the arrangement of matter on large scales behaves in many respects like a <b>cellular system</b>." </div>
      <div style="font-size: 18px; color: #555; margin-bottom: 2rem"
           class="page4-anim" data-delay="delay-3" id="page4-authors">
        Authors: Mark C. Neyrinck, Johan Hidding, Marina Konstantatou and Rien van de Weygaert
      </div>
    </div>
    <div class="scroll-arrow-next">&#8595;</div>
  `;
  scrollContainer.appendChild(page4);

  if (page3Arrow) page3Arrow.classList.add('show');

  const arrow = page4.querySelector('.scroll-arrow-next');

  // Observe when Page 4 enters viewport to start the fade-in animations
  const observer4 = new IntersectionObserver((entries, obs) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        // Use the entry.target (page4) to find animatable elements
        const els = entry.target.querySelectorAll('.page4-anim');
        els.forEach(el => {
          const delayClass = el.dataset.delay || '';
          // add both classes at once so animation delay applies correctly
          if (delayClass) el.classList.add('fade-in', delayClass);
          else el.classList.add('fade-in');
        });

        // show the page arrow after animations (adjust timing if you shorten fadeIn)
        setTimeout(() => { arrow.classList.add('show'); }, 2500);

        obs.disconnect();
        addPage5();
      }
    });
  }, { threshold: 0.35 }); // adjust threshold if you want earlier / later trigger

  observer4.observe(page4);
}
  // Observe when Page 4 enters viewport to trigger Page 5
  const observer4 = new IntersectionObserver(entries => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        observer4.disconnect();
        addPage5();
      }
    });
  }, { threshold: 0.5 });
  observer4.observe(page4);


function addPage5() {
  const page5 = document.createElement('div');
  page5.className = 'section';
  page5.innerHTML = `
  <div class="text-block-2" style="position:absolute; top:40vh; left:30vw; font-family: 'Cormorant Garamond', serif; font-size: 30px; line-height: 2;">
  Click to play <span class="arrow-right">&#8594;</span> <br>
  <a href="voronoi_spider.html">spider.</a> <br>
  <a href="voronoi_water.html">water.</a> <br>
  <a href="voronoiblackhole.html">black hole.</a> <br>
</div>
  `;
  scrollContainer.appendChild(page5);


  // Style links
  const links = page5.querySelectorAll('a');
  links.forEach(link => {
    link.style.color = 'black';
    link.style.textDecoration = 'underline';
    link.style.transition = 'color 0.3s';
    link.addEventListener('mouseover', () => link.style.color = 'gray');
    link.addEventListener('mouseout', () => link.style.color = 'black');
  });
}

</script>
</body>
</html>

